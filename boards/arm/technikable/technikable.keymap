#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/outputs.h>

#include "helper/functions.h"
#include "helper/keypos.h"

// Layers
#define BASE 0
#define SYMS 1
#define ADJT 2
#define CDR1 3
#define CDR2 4
#define CDN1 5

// Modifier Combos
#define LSG(kc) LS(LG(kc))
#define LSA(kc) LS(LA(kc))
#define LSC(kc) LS(LC(kc))
#define LAG(kc) LA(LG(kc))
#define LCG(kc) LC(LG(kc))
#define LCA(kc) LC(LA(kc))

&lt {
    tapping-term-ms = <200>;
    quick-tap-ms = <150>;
};

&mt {
    tapping-term-ms = <125>;
};

&sk {
    release-after-ms = <2000>;
    quick-release;
    ignore-modifiers;
};

&sl {
    release-after-ms = <2000>;
};

&caps_word {
    continue-list = <LSHFT RSHFT DELETE BSPC UNDERSCORE MINUS>;
};

/ {
    chosen {
       zmk,matrix_transform = &mit_transform;
    };

    macros {
        ZMK_BEHAVIOR(dif_co, macro,
            bindings = <&kp LSG(D) &kp C>;
        )
        ZMK_BEHAVIOR(dif_br, macro,
            bindings = <&kp LSG(D) &kp B>;
        )
    };

    behaviors {
        #define F_AS(kc) &fas LS(kc) kc
        #define M_AS(kc) &mas LS(kc) kc
        #define S_AS(kc) &sas LS(kc) kc

        // Hold Taps
        ZMK_BEHAVIOR(fas, hold_tap,
            flavor = "tap-preferred";
            tapping-term-ms = <145>;
            quick-tap-ms = <50>;
            global-quick-tap;
            bindings = <&kp>, <&kp>;
        )
        ZMK_BEHAVIOR(mas, hold_tap,
            flavor = "tap-preferred";
            tapping-term-ms = <175>;
            quick-tap-ms = <50>;
            global-quick-tap;
            bindings = <&kp>, <&kp>;
        ) 
        ZMK_BEHAVIOR(sas, hold_tap,
            flavor = "tap-preferred";
            tapping-term-ms = <200>;
            quick-tap-ms = <50>;
            global-quick-tap;
            bindings = <&kp>, <&kp>;
        )
        ZMK_BEHAVIOR(mod_sl, hold_tap,
            flavor = "balanced";
            tapping-term-ms = <200>;
            bindings = <&kp>, <&sl>;
        )
        ZMK_BEHAVIOR(cd, hold_tap,
            flavor = "tap-preferred";
            tapping-term-ms = <180>;
            quick-tap-ms = <50>;
            global-quick-tap;
            bindings = <&kp>, <&kp>;
        )
        ZMK_BEHAVIOR(nav, hold_tap,
            flavor = "tap-preferred";
            tapping-term-ms = <300>;
            quick-tap-ms = <50>;
            global-quick-tap;
            bindings = <&kp>, <&kp>;
        )
        
        // Mod Morphs
        ZMK_BEHAVIOR(bspc, mod_morph,
            bindings = <&nav LA(BSPC) BSPC>, <&nav LA(DEL) DEL>;
            mods = <(MOD_LSFT)>;
        )

        // Tap Dances
        ZMK_BEHAVIOR(shift_caps, tap_dance,
            tapping-term-ms = <400>; bindings = <&kp LSHIFT>, <&caps_word>; // 1:(shift), 2:(caps word)
        )
    };

    combos {
        compatible = "zmk,combos";
    
        // #undef COMBO_HOOK
        // #define COMBO_HOOK global-quick-tap-ms = <75>;
        #define FAST_COMBO_MS 30
        #define VERT_COMBO_MS 38
        #define SLOW_COMBO_MS 60

        // horizontal
        ZMK_COMBO_ADV(tilde,         M_AS(GRAVE),      LT4 LT3,          ALL,   FAST_COMBO_MS)
        ZMK_COMBO_ADV(lshift,        &shift_caps,      LB4 LB3,          ALL,   SLOW_COMBO_MS)
        ZMK_COMBO_ADV(rshift,        &shift_caps,      RB3 RB4,          ALL,   SLOW_COMBO_MS)
        ZMK_COMBO_ADV(esc,           &kp ESC,          LT3 LT2,          ALL,   FAST_COMBO_MS)
        ZMK_COMBO_ADV(tab,           &kp TAB,          LM3 LM2,          ALL,   FAST_COMBO_MS)
        ZMK_COMBO_ADV(backspace,     &bspc,            RT2 RT3,          ALL,   SLOW_COMBO_MS)
        ZMK_COMBO_ADV(enter,         &kp ENTER,        RM2 RM3,          ALL,   FAST_COMBO_MS)
        ZMK_COMBO_ADV(equal,         M_AS(EQUAL),      RT3 RT4,          ALL,   FAST_COMBO_MS)
        
        // vertical
        ZMK_COMBO_ADV(pipe_qmark,    &mas QMARK PIPE,  LT3 LM3,          ALL,   VERT_COMBO_MS)
        ZMK_COMBO_ADV(quotes,        M_AS(SQT),        RT3 RM3,          ALL,   VERT_COMBO_MS)
                                                    
        // angled                                   
        ZMK_COMBO_ADV(fslash,        &kp FSLH,         RH1 RB2,          ALL,   FAST_COMBO_MS)
        ZMK_COMBO_ADV(bslash,        &kp BSLH,         RM3 RB4,          ALL,   FAST_COMBO_MS)
                                                    
        // thumbs                                   
        ZMK_COMBO_ADV(alt,           &kp LALT,         RH1 RH2,          ALL,   SLOW_COMBO_MS)
                                                    
        ZMK_COMBO_ADV(lh_brc_lp,     &mas RPAR LPAR,   LH0 LT3,          ALL,   SLOW_COMBO_MS)
        ZMK_COMBO_ADV(lh_brc_lc,     &mas RBRC LBRC,   LH0 LT2,          ALL,   SLOW_COMBO_MS)
        ZMK_COMBO_ADV(lh_brc_la,     &mas GT LT,       LH0 LM3,          ALL,   SLOW_COMBO_MS)
        ZMK_COMBO_ADV(lh_brc_ls,     &mas RBKT LBKT,   LH0 LM2,          ALL,   SLOW_COMBO_MS)
        
        ZMK_COMBO_ADV(rh_brc_lp,     &mas RPAR LPAR,   RH0 LT3,          ALL,   SLOW_COMBO_MS)
        ZMK_COMBO_ADV(rh_brc_lc,     &mas RBRC LBRC,   RH0 LT2,          ALL,   SLOW_COMBO_MS)
        ZMK_COMBO_ADV(rh_brc_la,     &mas GT LT,       RH0 LM3,          ALL,   SLOW_COMBO_MS)
        ZMK_COMBO_ADV(rh_brc_ls,     &mas RBKT LBKT,   RH0 LM2,          ALL,   SLOW_COMBO_MS)

        ZMK_COMBO_ADV(lh_brc_rp,     &mas LPAR RPAR,   LH0 RT3,          ALL,   SLOW_COMBO_MS)
        ZMK_COMBO_ADV(lh_brc_rc,     &mas LBRC RBRC,   LH0 RT2,          ALL,   SLOW_COMBO_MS)
        ZMK_COMBO_ADV(lh_brc_ra,     &mas LT GT,       LH0 RM3,          ALL,   SLOW_COMBO_MS)
        ZMK_COMBO_ADV(lh_brc_rs,     &mas LBKT RBKT,   LH0 RM2,          ALL,   SLOW_COMBO_MS)
        
        ZMK_COMBO_ADV(rh_brc_rp,     &mas LPAR RPAR,   RH0 RT3,          ALL,   SLOW_COMBO_MS)
        ZMK_COMBO_ADV(rh_brc_rc,     &mas LBRC RBRC,   RH0 RT2,          ALL,   SLOW_COMBO_MS)
        ZMK_COMBO_ADV(rh_brc_ra,     &mas LT GT,       RH0 RM3,          ALL,   SLOW_COMBO_MS)
        ZMK_COMBO_ADV(rh_brc_rs,     &mas LBKT RBKT,   RH0 RM2,          ALL,   SLOW_COMBO_MS)

        // admin
        ZMK_COMBO_ADV(lh_boot,       &bootloader,      LH0 LB0 LB1 LB2,  BASE,  SLOW_COMBO_MS)  
        ZMK_COMBO_ADV(lh_lock_scrn,  &kp LCG(Q),       LT1 LT2 LT3 LT4,  BASE,  SLOW_COMBO_MS)  
        ZMK_COMBO_ADV(rh_lock_scrn,  &kp LCG(Q),       RT1 RT2 RT3 RT4,  BASE,  SLOW_COMBO_MS)  
    };

    keymap {
        compatible = "zmk,keymap";

        #define XXXXXXX  &none
        #define _______  &trans
        #define TO_BS()  &to BASE
        #define DEAD_MIDDLE()  XXXXXXX XXXXXXX
        #define DEAD_THUMBS()  XXXXXXX

        ZMK_LAYER(base_layer,
        #define LG_CR()  &mod_sl LCMD CDR1
        #define LC_CN()  &mod_sl LCTRL CDN1
        #define LA_CN()  &mod_sl LALT CDN1
        #define K_COM()  &kp COMMA
        #define SYMSP()  &lt SYMS SPACE

S_AS(Q)  M_AS(W)  F_AS(F)  F_AS(P)  M_AS(D)     DEAD_MIDDLE()    M_AS(J)  F_AS(L)  F_AS(U)  M_AS(Y)  S_AS(MINUS)
S_AS(A)  M_AS(R)  F_AS(S)  F_AS(T)  F_AS(G)     DEAD_MIDDLE()    F_AS(M)  F_AS(N)  F_AS(E)  M_AS(I)  S_AS(O)
S_AS(Z)  M_AS(X)  F_AS(C)  F_AS(V)  F_AS(B)     DEAD_MIDDLE()    F_AS(K)  F_AS(H)  K_COM()  &kp DOT  S_AS(SEMI)
                  LC_CN()  LG_CR()  SYMSP()     DEAD_THUMBS()    SYMSP()  LG_CR()  LA_CN()
        )

        ZMK_LAYER(symbols_layer,
        #define ADJSP()  &lt ADJT SPACE
        #define NUMB(n)  &kp N ## n
        #define NAV_U()  &kp UP
        #define NAV_D()  &kp DOWN
        #define NAV_L()  &nav LA(LEFT) LEFT     // right, right by a word
        #define NAV_R()  &nav LA(RIGHT) RIGHT   // left, left by a word
        #define K_BWD()  &nav LG(LBRC) LG(LBKT) // back, move to tab on left
        #define K_FWD()  &nav LG(RBRC) LG(RBKT) // forwards, move to tab on right

NUMB(0)  NUMB(1)  NUMB(2)  NUMB(3)  &kp CARET   DEAD_MIDDLE()    K_BWD()  K_FWD()  NAV_U()  XXXXXXX  _______
&kp EXCL NUMB(4)  NUMB(5)  NUMB(6)  &kp DLLR    DEAD_MIDDLE()    &kp AMPS NAV_L()  NAV_D()  NAV_R()  XXXXXXX
&kp AT   NUMB(7)  NUMB(8)  NUMB(9)  &kp PRCNT   DEAD_MIDDLE()    &kp HASH &kp STAR _______  _______  _______
                  _______  _______  ADJSP()     DEAD_THUMBS()    ADJSP()  _______  _______
        )

        ZMK_LAYER(adjust_layer,
        #define FUNC(n)  &kp F ## n
        #define VMUTE()  &kp C_MUTE 
        #define CH_KB()  &kp LCA(SPACE)
        #define SNCAP()  &kp LSG(N4)
        #define VOL(dir) &kp C_VOL_ ## dir
        #define BRI(dir) &kp C_BRI_ ## dir
        #define BT_S(n)  &bt BT_SEL n
        #define BT_CL()  &bt BT_CLR

TO_BS()  FUNC(1)  FUNC(2)  FUNC(3)  XXXXXXX     DEAD_MIDDLE()    VOL(DN)  VOL(UP)  VMUTE()  XXXXXXX  XXXXXXX
XXXXXXX  FUNC(4)  FUNC(5)  FUNC(6)  XXXXXXX     DEAD_MIDDLE()    BRI(DN)  BRI(UP)  SNCAP()  CH_KB()  XXXXXXX
BT_CL()  FUNC(7)  FUNC(8)  FUNC(9)  XXXXXXX     DEAD_MIDDLE()    BT_S(0)  BT_S(1)  BT_S(2)  BT_S(3)  BT_S(4)
                  _______  _______  XXXXXXX     DEAD_THUMBS()    XXXXXXX  _______  _______
        )

        ZMK_LAYER(code_ref1_layer,
        #define CDR_A()  &kp F5             // copy (putting it beside R which is rename/move)
        #define CDR_R()  &cd LS(F6) F6      // rename, move
        #define CDR_C()  &kp LAG(C)         // extract constant
        #define CDR_F()  &kp LAG(F)         // extract field
        #define CDR_P()  &kp LAG(P)         // extract parameter
        #define CDR_V()  &kp LAG(V)         // extract variable
        #define CDR_N()  &kp LAG(N)         // inline
        #define CDR_M()  &kp LAG(M)         // extract method
        #define CDR_L()  &kp LAG(L)         // format
        #define CDR_I()  &kp LAG(L)         // format (qwerty position)
        #define CDR_S()  &kp LAG(T)         // surround
        #define CDR_O()  &kp LA(ENTER)      // suggested actions
        #define CDR_B()  &cd LG(F9) LSG(F9) // build module, build all
        #define CDR_ES() &kp LA(UP)         // extend selection by scope
        #define CDR_DS() &kp LA(DOWN)       // decrease selection by scope

TO_BS()  XXXXXXX  CDR_F()  CDR_P()  XXXXXXX     DEAD_MIDDLE()    XXXXXXX  CDR_L()  CDR_ES() XXXXXXX  XXXXXXX
CDR_A()  CDR_R()  CDR_S()  CDN_T()  XXXXXXX     DEAD_MIDDLE()    CDR_M()  CDR_N()  CDR_DS() CDR_I()  CDR_O()
XXXXXXX  XXXXXXX  CDR_C()  CDR_V()  CDR_B()     DEAD_MIDDLE()    XXXXXXX  XXXXXXX  XXXXXXX  XXXXXXX  XXXXXXX
                  XXXXXXX  XXXXXXX  XXXXXXX     DEAD_THUMBS()    XXXXXXX  XXXXXXX  XXXXXXX
        )

        ZMK_LAYER(code_ref2_layer,
        #define CDR_CS() &kp LG(F6)               // change signature
        #define CDR_MU() &cd LSA(UP) LSG(UP)      // move line up, move block up
        #define CDR_MD() &cd LSA(DOWN) LSG(DOWN)  // move line down, move block down

// TO_BS()  XXXXXXX  XXXXXXX  XXXXXXX  XXXXXXX     DEAD_MIDDLE()    XXXXXXX  XXXXXXX  CDR_MU() XXXXXXX  XXXXXXX
// XXXXXXX  CDR_CS() XXXXXXX  XXXXXXX  XXXXXXX     DEAD_MIDDLE()    XXXXXXX  XXXXXXX  CDR_MD() CDR_I()  CDR_O()
// XXXXXXX  XXXXXXX  XXXXXXX  XXXXXXX  XXXXXXX     DEAD_MIDDLE()    XXXXXXX  XXXXXXX  XXXXXXX  XXXXXXX  XXXXXXX
//                   XXXXXXX  XXXXXXX  XXXXXXX     DEAD_THUMBS()    XXXXXXX  XXXXXXX  XXXXXXX
TO_BS()  XXXXXXX  XXXXXXX  XXXXXXX  XXXXXXX     DEAD_MIDDLE()    XXXXXXX  XXXXXXX  XXXXXXX  XXXXXXX  XXXXXXX
XXXXXXX  CDR_CS() XXXXXXX  XXXXXXX  XXXXXXX     DEAD_MIDDLE()    XXXXXXX  XXXXXXX  XXXXXXX  CDR_I()  CDR_O()
XXXXXXX  XXXXXXX  XXXXXXX  XXXXXXX  XXXXXXX     DEAD_MIDDLE()    XXXXXXX  XXXXXXX  XXXXXXX  XXXXXXX  XXXXXXX
                  XXXXXXX  XXXXXXX  XXXXXXX     DEAD_THUMBS()    XXXXXXX  XXXXXXX  XXXXXXX
        )

        ZMK_LAYER(code_nav_layer,
        #define CDN_F() &cd LSG(R) LSG(F)   // find in project, replace in project
        #define CDN_P() &kp LG(N1)          // project tree tab
        #define CDN_S() &kp LG(F12)         // find symbol in file
        #define CDN_T() &kp LSG(T)          // navigate to/from tests
        #define CDN_E() &cd LS(F2) F2       // go to next/last error
        #define CDN_R() &cd LG(N4) LSC(R)   // run tests, open run window
        #define CDN_D() &cd LG(N5) LSC(D)   // run tests in debug mode, open debug window
        #define DBG_I() &cd F7 LS(F7)       // debug: smart step into, step into
        #define DBG_O() &cd LS(F8) F8       // debug: step over, step out
        #define DBG_R() &cd LA(F9) LAG(R)   // debug: run until breakpoint, run until cursor
        #define DBG_B() &cd LG(F8) LA(F8)   // debug: evaluate expression, set breakpoint

TO_BS()  XXXXXXX  CDN_F()  CDN_P()  CDN_D()     DEAD_MIDDLE()    XXXXXXX  DBG_I()  DBG_O()  DBG_R()  DBG_B()
XXXXXXX  CDN_R()  CDN_S()  CDN_T()  XXXXXXX     DEAD_MIDDLE()    XXXXXXX  XXXXXXX  CDN_E()  XXXXXXX  CDR_O()
XXXXXXX  XXXXXXX  &dif_co  XXXXXXX  &dif_br     DEAD_MIDDLE()    XXXXXXX  XXXXXXX  XXXXXXX  XXXXXXX  XXXXXXX
                  XXXXXXX  XXXXXXX  XXXXXXX     DEAD_THUMBS()    XXXXXXX  XXXXXXX  XXXXXXX
        )
    };
};